substitutions:
  name: kauf-plug
  friendly_name: Kauf Plug

esp8266:                       # https://esphome.io/components/esp8266.html
  board: esp01_1m
  restore_from_flash: true

external_components:
  - source:
      type: git
      url: https://github.com/KaufHA/PLF10
    refresh: 0s
  # - source:
  #     type: local
  #     path: kauf_plf10_components

preferences:
  flash_write_interval: 3s

esphome:

  name: $name
  name_add_mac_suffix: true

  project:
    name: "kauf.plf10"
    version: "1.83"

  on_boot:
    then:

      # wait until ESPHome tries loading wifi credentials
      - wait_until:
          lambda: 'return ( wifi_wificomponent->tried_loading_creds );'


      - if:
          condition: # don't do anything if credentials were loaded unless force_ap is on as override
            lambda: 'return ( wifi_wificomponent->loaded_creds && !id(force_ap) );'
          then:
            - logger.log: "------------------->>>>>>>>>>>>>>>>>   wifi already configured, leaving ap timeout cranked"

            - globals.set:  # set global so if wifi never connects we'll have AP next time.
                id: force_ap
                value: 'true'

            - wait_until:
                wifi.connected
            - globals.set:  # clear global so we won't have AP next time
                id: force_ap
                value: 'false'

          # if we do need AP 
          else:           # if credentials not loaded or force_ap is set, lower ap timeout to allow saving new credentials
            - logger.log: "------------------->>>>>>>>>>>>>>>>>   wifi not configured, enabling ap and waiting"
              # set ap timeout to 15 seconds in milliseconds.
            - lambda: 'wifi_wificomponent->set_ap_timeout(15000);'
            - wait_until:
                wifi.connected
            - globals.set:  # clear global so ap doesn't come back up next time
                id: force_ap
                value: 'false'

              # set ap timeout to max 32 bit value in milliseconds.  About 3.5 weeks.
            - logger.log: "------------------->>>>>>>>>>>>>>>>>   wifi connected, cranking ap timeout back up"
            - lambda: 'wifi_wificomponent->set_ap_timeout(2147483647);'

globals:
  - id: force_ap
    type: bool
    restore_value: yes
    initial_value: "true"

dashboard_import:
  package_import_url: github://KaufHA/PLF10/kauf-plug.yaml

wifi:

  # default credentials as backup.  Also needed to show found networks in captive portal.
  ssid: initial_ap2
  password: asdfasdfasdfasdf

  # use_address allows wireless programming through dashboard.  remove after programming.
  # use_address: 192.168.86.202

  # default is 20, 17 is recommended.
  output_power: 17

  ap:
    ssid: ${friendly_name} Hotspot
    ap_timeout: 2147483647ms          # default to max 32-bit value in milliseconds.  About 3.5 weeks.


captive_portal:                       # for fallback wifi hotspot

logger:                               # Enable logging
  # baud_rate: 0                      # Disable UART logging since TX pad not easily available

api:                                  # Enable Home Assistant API
  # password: !secret api_password    # optional password field for Home Assistant API.

ota:
  # password: !secret ota_password    # optional password for OTA updates.

debug:                                # outputs additional debug info when logs start

web_server:                           # web server allows access to device with a web browser
  # auth:                             # optional login details for web interface
  #   username: admin
  #   password: !secret web_server_password

  # host css and js file directly on device
  css_include: "webserver-v1.min.css"
  css_url: ""
  js_include: "webserver-v1.min.js"
  js_url: ""


# red led, blink when not connected to WiFi or Home Assistant
status_led:
    pin:
      number: GPIO0
      inverted: true

  
binary_sensor:  

    # button input toggles relay and thereby blue led
  - platform: gpio
    id: button_in
    name: $friendly_name Button
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
    entity_category: ''
    

    on_click:

      - min_length: 30ms
        max_length: 2s
        then:
          - if:
              condition: # only toggle relay if button is enabled
                lambda: 'return (id(select_button).state == "Enabled");'
              then:
                switch.toggle: relay



        # restart with AP enabled if button is held for 5 seconds (up to 30 seconds because ESPHome requires a max).
        # Not disabled by button disable option because you may not be able to re-enable button if wifi is not connecting.
        # If your kid accidentally triggers this, the plug will just reboot and reconnect to wifi.  Shouldn't harm anything.

      - min_length: 5s
        max_length: 30s
        then:
          - logger.log: "------------------->>>>>>>>>>>>>>>>>   HELD BUTTON 5 SECONDS, FORCING AP"
  
          # blink LED for 10s then restart to get captive portal to turn on.
          - globals.set:
              id: force_ap
              value: 'true'
          - script.execute: blink_led
          - delay: 10s

          # we have to restart because ESPHome's AP won't show the captive portal once wifi has been connected.
          - button.press: restart_button


    # indicates whether plugged-in device is running based on configurable threshold.
  - platform: template
    id: in_use
    name: ${friendly_name} Device In Use


script:
    # blink LED forever.  Used when button is held to re-enable AP.  Stops blinking because plug restarts.
  - id: blink_led
    mode: queued
    then:
      - switch.toggle: blue_led
      - delay: 333ms
      - script.execute: blink_led
    # clear wifi credentials and reboot.  causes AP to be enabled.
  - id: clear_wifi_script
    then:
      - lambda: 'wifi_wificomponent->clear_stored_creds();'
      - delay: 2s
      - button.press: restart_button

switch:    

    # blue LED follows relay power state
  - platform: gpio
    id: blue_led
    pin:
      number: GPIO2
      inverted: true

    # relay output
  - platform: gpio
    id: relay
    name: $friendly_name
    pin: GPIO4
    entity_category: ''

    # automatically make blue led equal relay state
    on_turn_on:
      - if:
          condition: # only if blue LED enabled
            lambda: 'return (id(select_led).state == "Enabled");'
          then:
            switch.turn_on: blue_led

    on_turn_off:
      - switch.turn_off: blue_led

button:
  - platform: restart
    id: restart_button
    name: $friendly_name Restart Firmware
    entity_category: diagnostic
    disabled_by_default: true
  - platform: template
    id: clear_wifi_button
    name: $friendly_name Clear Wifi Credentials
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      then:
        script.execute: clear_wifi_script

# clock input from Home Assistant used to calculate total daily energy
time:
  - platform: homeassistant
    id: homeassistant_time


sensor:   # Power monitoring sensors output to Home Assistant
  - platform: hlw8012
    sel_pin:
      number: GPIO12
      inverted: True
    cf_pin: GPIO5
    cf1_pin: GPIO14
    current_resistor: 0.001 # The value of the shunt resistor for current measurement. 
    voltage_divider: 2401   # The value of the voltage divider on the board as (R_upstream + R_downstream) / R_downstream. 
    power:
      name: ${friendly_name} Power
      unit_of_measurement: W
      id: wattage
      filters:
        - calibrate_linear:
            - 0.0 -> 0.0  
            - 333.8 -> 60 # value with 60W bulb.
      on_value:   # set or clear in_use template binary sensor depending on whether power usage is over threshold
        - if:
            condition:
              lambda: 'return (x >= id(threshold).state);'
            then:
              - binary_sensor.template.publish:
                  id: in_use
                  state: ON
            else:
              - binary_sensor.template.publish:
                  id: in_use
                  state: OFF
    current:
      name: ${friendly_name} Current
      unit_of_measurement: A
      filters:
        - calibrate_linear:
            - 0.0 -> 0.0
            - 0.6 -> 0.515  # value with 60W bulb.
    voltage:
      name: ${friendly_name} Voltage
      unit_of_measurement: V
      filters:
        - calibrate_linear:
            - 0.0 -> 0.0
            - 302.1 -> 117.1 # Tested using a meter
    change_mode_every: 1 
    update_interval: 10s # 20 second effective update rate for Power, 40 second for Current and Voltage.

# Reports the total Power so-far each day, resets at midnight
# See https://esphome.io/components/sensor/total_daily_energy.html
  - platform: total_daily_energy
    name: ${friendly_name} Total Daily Energy
    power_id: wattage
    filters:
        - multiply: 0.001  ## convert Wh to kWh
    unit_of_measurement: kWh


number:      # used as a threshold for whether the plugged-in devices is running.
  - platform: template
    name: ${friendly_name} Use Threshold
    min_value: 1
    max_value: 100
    step: 1
    initial_value: 3
    id: threshold
    entity_category: config
    optimistic: true     # required for changing value from home assistant
    restore_value: true
    unit_of_measurement: Watt(s)
    mode: box
    on_value:
      - if:               # set or clear in_use template binary sensor depending on whether power usage is above threshold
          condition:
            lambda: 'return (id(wattage).state >= x);'
          then:
            - binary_sensor.template.publish:
                id: in_use
                state: ON
          else:
            - binary_sensor.template.publish:
                id: in_use
                state: OFF


select:

    # option to disable button
  - platform: template
    name: $friendly_name Button
    id: select_button
    optimistic: true
    options:
      - Enabled
      - Disabled
    initial_option: Enabled
    restore_value: true
    icon: mdi:circle-double
    entity_category: config


    # option to disable blue LED
  - platform: template
    name: $friendly_name LED
    id: select_led
    optimistic: true
    entity_category: config
    options:
      - Enabled
      - Disabled
    initial_option: Enabled
    restore_value: true
    icon: mdi:led-on
    on_value:
      then:
      - if:
          condition:
            lambda: 'return ( (id(select_led).state == "Enabled") && id(relay).state );'
          then:
            switch.turn_on: blue_led
          else:
            switch.turn_off: blue_led


# Send IP Address to HA
text_sensor:
  - platform: wifi_info
    ip_address:
      name: $friendly_name IP Address
      disabled_by_default: true
